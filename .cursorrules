# Cursor Rules: Modular CQRS-DDD Toolkit

You are the Lead Architect for the CQRS-DDD Toolkit. Ensure all code follows the architectural guidelines in the project's system prompts.

## 1. Project layout and packages

- **Monorepo:** Code lives under `packages/`. Do not assume legacy top-level packages (e.g. `cqrs-ddd-core/`).
- **Five implemented packages:**
  - `packages/core` — Domain primitives, CQRS, ports, in-memory adapters. **Zero infrastructure dependencies.**
  - `packages/advanced` — Sagas, TCC, background jobs, scheduling, conflict resolution, snapshots, upcasting, undo.
  - `packages/specifications` — Specification pattern and query building.
  - `packages/persistence/sqlalchemy` — Write-side persistence (event store, outbox, repositories).
  - `packages/infrastructure/redis` — Redis-backed adapters (cache, locks, etc.).
- **Planned packages** are organized under `packages/persistence/`, `packages/infrastructure/`, `packages/features/`, `packages/engines/`, `packages/bridges/`, `packages/cli/`, and `packages/container/`. Each has a `.prompt.md` specification file.
- **Modular rules:** Before changing a package, check for a local `.prompt.md` or `system-prompt.md` in that package and follow it. Global rules are in `/system-prompt.md`.

## 2. Core philosophy and terminology

- **Naming:** Use `AggregateRoot` (not “Aggregate”). Use `Saga` / `SagaState` / `SagaManager` as in the advanced package.
- **Strict isolation:** `packages/core` must remain pure Python (no SQLAlchemy, Redis, etc.). Only stdlib and optional Pydantic.
- **Persistence:** State-stored aggregates with outbox by default. Events and side effects go through the outbox in the same transaction.
- **Serialization:** Domain events must be JSON/BSON-serializable; implement `.model_dump()` consistently.
- **Mixins:** Use mixins for cross-cutting concerns (e.g. `AuditableMixin`, `ArchivableMixin`). Avoid deep inheritance.

## 3. Protocols and implementations

- **Ports = Protocols:** All ports are `typing.Protocol` with `@runtime_checkable`. Defined under each package’s `ports/` (e.g. `core/ports/`, `advanced/ports/`).
- **Explicit protocol extension:** Adapters and middleware must **declare** the protocol they implement (e.g. `class InMemoryOutboxStorage(IOutboxStorage):`, `class LoggingMiddleware(IMiddleware):`). Relying only on structural typing is not enough.
- **Repository search:** `IRepository.search()` returns `SearchResult[T]`, not `list[T]`. Use the protocol’s `SearchResult` (await for list, or `.stream()` for iteration).
- **Workers:** Background workers implement `IBackgroundWorker` and use a **reactive** pattern: `trigger()` plus polling fallback (same idea as `BufferedOutbox`).

## 4. Implementation standards

- **Pydantic:** Use Pydantic for `AggregateRoot`, `DomainEvent`, `Command` where applicable. Use `ConfigDict(frozen=True)` for immutability where needed.
- **JSON in persistence:** In SQLAlchemy packages, use the project’s `JSONType` (or equivalent) so Postgres vs SQLite behave correctly in tests.
- **Optimistic locking:** Aggregate persistence must support a `version` field and enforce it on updates.
- **Immutability:** Domain events and commands should be immutable (e.g. `frozen=True`).
- **Async:** All repository, UoW, event store, outbox, and worker lifecycle methods are `async`.
- **Typing:** Use strict type hints and `Generic[T]` for repositories/aggregates. Use `from __future__ import annotations` in modules.

## 5. File and structure conventions

- **Ports:** Protocol definitions live in `ports/` (e.g. `ports/repository.py`, `ports/outbox.py`).
- **Adapters:** In-memory or test doubles live under `adapters/memory/` (or package-specific `adapters/`). They must explicitly implement the corresponding port.
- **Sagas (advanced):** Hand-written sagas must set class-level `listens_to`. For declarative sagas without subclassing, use `SagaBuilder`; it sets `listens_to` when building the class.

## 6. Tooling and quality

- **Lint/format:** Use `ruff` for linting and formatting.
- **Types:** Use `pyright` (or the project’s chosen type checker) for static typing.
- **Tasks:** Use `nox` for test, lint, and type-check tasks where configured.
- **Tests:** Unit tests under `[package]/tests/`; integration/architecture tests under `tests/` at repo root. Use pytest. Enforce layer boundaries (e.g. core must not import persistence) via architecture tests where applicable.
- **Coverage:** Aim for high coverage on domain and application code; exclude trivial boilerplate from targets.

## 7. Testing practices

- **TDD:** Prefer writing tests before or alongside domain/application logic when adding behavior.
- **In-memory first:** Prefer in-memory adapters from core/advanced for unit tests; avoid real DBs unless integration tests require it.
- **Isolation:** Do not let core depend on persistence or messaging packages. Respect dependency direction (e.g. advanced → core, persistence → core).

## 8. Exceptions

- **Prefer package exceptions** over bare `ValueError` / `RuntimeError` for domain and infrastructure failures. Use exceptions from `cqrs_ddd_core.primitives.exceptions` and package-specific modules (e.g. `cqrs_ddd_advanced_core.exceptions`).
- **Hierarchy:** Core defines the root (`CQRSDDDError`) and broad categories (`DomainError`, `HandlerError`, `ValidationError`, `PersistenceError`). Packages (e.g. advanced, specifications) add concrete types that inherit from these where appropriate.
- **When to use what:**
  - **DomainError** (and subclasses such as **JobStateError**): invalid domain state or state-machine transitions (e.g. job already completed, invalid transition).
  - **HandlerError** / **HandlerNotRegisteredError**: no handler registered for a command/event type, or handler invocation failures.
  - **ValidationError** / **SagaConfigurationError**: invalid configuration or build-time validation (e.g. invalid saga `.on()` args, TCC step names, duplicate events).
  - **SagaStateError**: invalid saga runtime state (e.g. no TCC steps, TCC already started, `message_registry` required).
  - **PersistenceError**: repository, event store, or UoW failures.
- **When to keep built-ins:** Use `ValueError` only for truly generic argument validation (e.g. “Streaming requires an explicit UnitOfWork”) where no existing package exception fits. Packages with their own domain (e.g. specifications) may define their own root (e.g. `SpecificationError`).

THe project uses virtual environment for python in .venv folder

Refer to `/system-prompt.md` for the full architecture and package roles, and to `/README.md` for the package ecosystem overview.
